---
title: "Model data with missing observations using multiple imputation"
author: "Thierry Onkelinx"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Model data with missing observations using multiple imputation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{ggplot2}
  %\VignetteDepends{INLA}
  %\VignetteDepends{mgcv}
---

```{r settings, echo = FALSE}
knitr::opts_chunk$set(
  fig.width = 7.1,
  fig.height = 5
)
```

# How to

1. Create the imputation model
1. Generate imputations for the missing observation
1. Aggregate the imputed data
1. Model the aggregated imputed data

# Generate data

First, let's generate a dataset and set some observations missing. `generateData()` creates a balanced dataset with repeated visits of a number of sites. Each site is visited several years and multiple times per year. Have a look at the help-file of `generateData()` for more details on the model. 

```{r generate_data}
library(multimput)
set.seed(123)
prop.missing <- 0.5
dataset <- generateData(
  n.year = 10, n.period = 6, n.site = 50, 
  n.run = 1
)
dataset$Observed <- dataset$Count
which.missing <- sample(nrow(dataset), size = nrow(dataset) * prop.missing)
dataset$Observed[which.missing] <- NA
dataset$fYear <- factor(dataset$Year)
dataset$fPeriod <- factor(dataset$Period)
dataset$fSite <- factor(dataset$Site)
str(dataset)
```

Variables in dataset

Year
  ~ The year of the observation as an integer
  
fYear
  ~ The year of the observation as a factor

Period
  ~ The period of the observation as an integer
  
fPeriod
  ~ The period of the observation as a factor
  
Site
  ~ The ID of the site as an integer
  
fSite
  ~ The ID of the site as a factor
  
Mu
  ~ The expected value of a negative binomial distribution
  
Count
  ~ A realisation of a negative binomial distribution with expected value `Mu`
  
Observed
  ~ The `Count` variable with missing data

```{r plot_data}
library(ggplot2)
ggplot(dataset, aes(x = Year, y = Mu, group = Site)) + 
  geom_line() + 
  facet_wrap(~Period) + 
  scale_y_log10()
```

# Create the imputation model

We will create several models, mainly to illustrate the capabilities of the `multimput` package. Hence several of the models are not good for a real life application.

```{r imputation_model}
imp.lm <- lm(Observed ~ fYear + fPeriod + fSite, data = dataset)
library(INLA)
imp.inla.p <- inla(
  Observed ~ fYear + fPeriod + f(Site, model = "iid"), 
  data = dataset, 
  family = "poisson", 
  control.predictor = list(compute = TRUE)
)
imp.inla.nb <- inla(
  Observed ~ fYear + fPeriod + f(fSite, model = "iid"), 
  data = dataset, 
  family = "nbinomial", 
  control.predictor = list(compute = TRUE)
)
dataset$YearCopy <- dataset$Year
imp.better <- inla(
  Observed ~ f(Year, model = "rw1") + f(YearCopy, model = "ar1", replicate = Site) + 
    fPeriod, 
  data = dataset, 
  family = "nbinomial", 
  control.predictor = list(compute = TRUE)
)
```

# Apply the imputation model

Most models have a `predict` method. In such a case `impute()` requires both a `model` and a `data` argument. Note that this implies that one can apply an imputation on any dataset as long as the dataset contains the necessary variables.

`inla` do the prediction simultaneously with the model fitting. Hence the model contains all required information and the `data` is not used.

`n.imp` is the number of imputations. The default is `n.imp = 19`.

```{r impute}
raw.lm <- impute(imp.lm, data = dataset)
raw.inla.p <- impute(imp.inla.p)
raw.inla.nb <- impute(imp.inla.nb)
raw.better <- impute(imp.better)
raw.better.199 <- impute(imp.better, n.imp = 9)
```

# Aggregate the imputated dataset

Suppose that we are interested in the sum of the counts over all sites for each combination of year and period. Then we must aggregate the imputations on year and period. The resulting object will only contain the imputated response and the grouping variables. The easiest way to have a variable like year both a continuous and factor is to add both `Year` and `fYear` to the `grouping`.

```{r aggregate}
aggr.lm <- aggregate_impute(
  raw.lm, 
  grouping = c("fYear", "fPeriod", "Year"), 
  fun = sum
)
aggr.inla.p <- aggregate_impute(
  raw.inla.p, 
  grouping = c("fYear", "fPeriod", "Year"), 
  fun = sum
)
aggr.inla.nb <- aggregate_impute(
  raw.inla.nb, 
  grouping = c("fYear", "fPeriod", "Year"), 
  fun = sum
)
aggr.better <- aggregate_impute(
  raw.better, 
  grouping = c("fYear", "fPeriod", "Year"), 
  fun = sum
)
aggr.better.199 <- aggregate_impute(
  raw.better.199, 
  grouping = c("fYear", "fPeriod", "Year"), 
  fun = sum
)
```

# Model the aggregated imputed dataset

## Simple example

`model_impute()` will apply the `model.fun` to each imputation set. The covariates are defined in the `rhs` argument. When the user doesn't specify an `extractor.fun`, `model_impute()` will rely on `extractor()` to do the heavy lifting. This will return in many cases the estimates of all parameters and their standard errors. 

```{r model_aggregate_lm}
model_impute(
  aggr.lm, 
  model.fun = lm, 
  rhs = "0 + fYear + fPeriod"
)
model_impute(
  aggr.better, 
  model.fun = glm, 
  rhs = "0 + fYear + fPeriod",
  model.args = list(family = "poisson")
)
```

## A custom `extractor.fun`

Sometimes `extractor()` can't handle the `model.fun`. Or the user is in interested in another set of parameters. In such case the use can specify his own `extractor` and pass it to `extractor.fun`. This is a user defined function which must have an argument called `model`. The function should return a `data.frame` or `matrix` with two columuns. The first column hold the estimate of a parameter of the `model`, the second column their standard error. Each row represents a parameter. 

The `extractor.fun` function requires more work from the user. This cost is compensated by the high degree of flexibility. The user doesn't depend on the predefined extractor functions. This is illustrated by the following examples.


```{r model_aggregate_lm_bis}
# extra only the parameters fYear3 and fYear10
extractor.lm <- function(model){
  result <- summary(model)$coefficients[, c("Estimate", "Std. Error")]
  result[c("fYear3", "fYear10"), ]
}
model_impute(
  aggr.lm, 
  model.fun = lm, 
  rhs = "0 + fYear + fPeriod",
  extractor.fun = extractor.lm
)
```


## Predict a smoother for predefined values

Note that we pass extra arguments to the `extractor.fun` function through the `extractor.args` argument. This has to be a list. We recommend to use a named list to avoid confusion.

```{r model_aggregate_lm3}
library(mgcv)
new.set <- expand.grid(
  Year = pretty(dataset$Year, 20),
  fPeriod = dataset$fPeriod[1]
)
extractor.lm3 <- function(model, newdata){
  predictions <- predict(model, newdata = newdata, se.fit = TRUE)
  cbind(
    predictions$fit,
    predictions$se.fit
  )
}  
model.gam <- model_impute(
  aggr.lm, 
  model.fun = gam, 
  rhs = "s(Year) + fPeriod", 
  extractor.fun = extractor.lm3,
  extractor.args = list(newdata = new.set)
)
model.gam <- cbind(new.set, model.gam)
model.gam$LCL <- qnorm(0.025, mean = model.gam$Estimate, sd = model.gam$SE)
model.gam$UCL <- qnorm(0.975, mean = model.gam$Estimate, sd = model.gam$SE)
ggplot(model.gam, aes(x = Year, y = Estimate, ymin = LCL, ymax = UCL)) + 
  geom_ribbon(alpha = 0.1) + 
  geom_line()
```

## Compare the results using different imputation models

```{r model_inla}
covar <- data.frame(
  Year = sort(unique(dataset$Year))
)
extractor.inla <- function(model){
  fe <- model$summary.fixed[, c("mean", "sd")]
  fe[grepl("fYear", rownames(fe)), ]
}
model.p <- model_impute(
  object = aggr.inla.p,
  model.fun = inla,
  rhs = "0 + fYear + f(fPeriod, model = 'iid')",
  model.args = list(family = "nbinomial"),
  extractor.fun = extractor.inla
)
model.nb <- model_impute(
  object = aggr.inla.nb,
  model.fun = inla,
  rhs = "0 + fYear + f(fPeriod, model = 'iid')",
  model.args = list(family = "nbinomial"),
  extractor.fun = extractor.inla
)
model.better <- model_impute(
  object = aggr.better,
  model.fun = inla,
  rhs = "0 + fYear + f(fPeriod, model = 'iid')",
  model.args = list(family = "nbinomial"),
  extractor.fun = extractor.inla
)
aggr.complete <- aggregate(
  dataset[, "Count", drop = FALSE],
  dataset[, c("fYear", "fPeriod")],
  FUN = sum
)
m.complete <- inla(
  Count ~ 0 + fYear + f(fPeriod, model = "iid"),
  data = aggr.complete,
  family = "nbinomial"
)
model.complete <- extractor.inla(m.complete)
colnames(model.complete) <- c("Estimate", "SE")
parameters <- rbind(
  cbind(covar, model.p, Model = "poisson"),
  cbind(covar, model.nb, Model = "negative binomial"),
  cbind(covar, model.better, Model = "better"),
  cbind(covar, model.complete, Model = "complete")
)
parameters$LCL <- qnorm(0.025, mean = parameters$Estimate, sd = parameters$SE)
parameters$UCL <- qnorm(0.975, mean = parameters$Estimate, sd = parameters$SE)
ggplot(parameters, aes(x = Year, y = Estimate, ymin = LCL, ymax = UCL)) + 
  geom_ribbon(, alpha = 0.2) + 
  geom_line() + 
  facet_wrap(~Model)
```
